{
  "version": 3,
  "sources": ["../../use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../use-sync-external-store/shim/index.js", "../../@vaadin/hilla-react-signals/src/polyfills.ts", "../../@preact/signals-core/src/index.ts", "../../@preact/signals-react/runtime/src/index.ts", "../../nanoid/url-alphabet/index.js", "../../nanoid/index.browser.js", "../../@vaadin/hilla-react-signals/src/events.ts", "../../@vaadin/hilla-react-signals/src/FullStackSignal.ts", "../../@vaadin/hilla-react-signals/src/ValueSignal.ts", "../../@vaadin/hilla-react-signals/src/NumberSignal.ts", "../../@vaadin/hilla-react-signals/src/CollectionSignal.ts", "../../@vaadin/hilla-react-signals/src/ListSignal.ts"],
  "sourcesContent": ["/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n", "// TODO: Remove this polyfill when we move to ECMA2024\ndeclare global {\n  interface PromiseConstructor {\n    withResolvers<T>(): {\n      resolve(value: T): void;\n      reject(reason?: unknown): void;\n      promise: Promise<T>;\n    };\n  }\n}\n\nif (!('withResolvers' in Promise)) {\n  // eslint-disable-next-line no-extend-native\n  Object.defineProperty(Promise, 'withResolvers', {\n    configurable: true,\n    value<T>() {\n      let resolve: (value: T) => void;\n      let reject: (reason?: unknown) => void;\n      const promise = new Promise<T>((_resolve, _reject) => {\n        resolve = _resolve;\n        reject = _reject;\n      });\n      return { resolve: resolve!, reject: reject!, promise };\n    },\n  });\n}\n\nexport {};\n", "// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for(\"preact-signals\");\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn fn();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style prototypes.\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof BRAND_SYMBOL;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style prototypes.\n// This enables better control of the transpiled output size.\nfunction Signal(this: Signal, value?: unknown) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n}\n\nSignal.prototype.brand = BRAND_SYMBOL;\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tif (this._targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = this._targets;\n\t\tif (this._targets !== undefined) {\n\t\t\tthis._targets._prevTarget = node;\n\t\t}\n\t\tthis._targets = node;\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\treturn effect(() => {\n\t\tconst value = this.value;\n\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tfn(value);\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t}\n\t});\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\ttry {\n\t\treturn this.value;\n\t} finally {\n\t\tevalContext = prevContext;\n\t}\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget(this: Signal) {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tthrow new Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>;\nexport function signal<T = undefined>(): Signal<T | undefined>;\nexport function signal<T>(value?: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\t// If there's a new version of the dependency before or after refreshing,\n\t\t// or the dependency has something blocking it from refreshing at all (e.g. a\n\t\t// dependency cycle), then we need to recompute.\n\t\tif (\n\t\t\tnode._source._version !== node._version ||\n\t\t\t!node._source._refresh() ||\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n\t_fn: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(fn: () => T);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\nfunction Computed(this: Computed, fn: () => unknown) {\n\tSignal.call(this, undefined);\n\n\tthis._fn = fn;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._fn();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget(this: Computed) {\n\t\tif (this._flags & RUNNING) {\n\t\t\tthrow new Error(\"Cycle detected\");\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n\treadonly value: T;\n\tpeek(): T;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\tvalueOf(): T;\n\ttoString(): string;\n\ttoJSON(): T;\n\tbrand: typeof BRAND_SYMBOL;\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n\treturn new Computed(fn);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._fn = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectFn = () => void | (() => void);\n\ndeclare class Effect {\n\t_fn?: EffectFn;\n\t_cleanup?: () => void;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\n\tconstructor(fn: EffectFn);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n}\n\nfunction Effect(this: Effect, fn: EffectFn) {\n\tthis._fn = fn;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._fn === undefined) return;\n\n\t\tconst cleanup = this._fn();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tthrow new Error(\"Cycle detected\");\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n\tconst effect = new Effect(fn);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\treturn effect._dispose.bind(effect);\n}\n\nexport { computed, effect, batch, untracked, Signal, ReadonlySignal };\n", "import {\n\tsignal,\n\tcomputed,\n\teffect,\n\tSignal,\n\tReadonlySignal,\n} from \"@preact/signals-core\";\nimport {\n\tuseRef,\n\tuseMemo,\n\tuseEffect,\n\tuseLayoutEffect,\n\tversion as reactVersion,\n} from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nconst [major] = reactVersion.split(\".\").map(Number);\nconst Empty = [] as const;\n// V19 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\n// V18 https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\nconst ReactElemType = Symbol.for(\n\tmajor >= 19 ? \"react.transitional.element\" : \"react.element\"\n);\n\nexport function wrapJsx<T>(jsx: T): T {\n\tif (typeof jsx !== \"function\") return jsx;\n\n\treturn function (type: any, props: any, ...rest: any[]) {\n\t\tif (typeof type === \"string\" && props) {\n\t\t\tfor (let i in props) {\n\t\t\t\tlet v = props[i];\n\t\t\t\tif (i !== \"children\" && v instanceof Signal) {\n\t\t\t\t\tprops[i] = v.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsx.call(jsx, type, props, ...rest);\n\t} as any as T;\n}\n\nconst symDispose: unique symbol =\n\t(Symbol as any).dispose || Symbol.for(\"Symbol.dispose\");\n\ninterface Effect {\n\t_sources: object | undefined;\n\t_start(): () => void;\n\t_callback(): void;\n\t_dispose(): void;\n}\n\n/**\n * Use this flag to represent a bare `useSignals` call that doesn't manually\n * close its effect store and relies on auto-closing when the next useSignals is\n * called or after a microtask\n */\nconst UNMANAGED = 0;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a component's render method. This is the default usage\n * that the react-transform plugin uses.\n */\nconst MANAGED_COMPONENT = 1;\n/**\n * Use this flag to represent a `useSignals` call that is manually closed by a\n * try/finally block in a hook body. This is the default usage that the\n * react-transform plugin uses.\n */\nconst MANAGED_HOOK = 2;\n\n/**\n * An enum defining how this store is used. See the documentation for each enum\n * member for more details.\n * @see {@link UNMANAGED}\n * @see {@link MANAGED_COMPONENT}\n * @see {@link MANAGED_HOOK}\n */\ntype EffectStoreUsage =\n\t| typeof UNMANAGED\n\t| typeof MANAGED_COMPONENT\n\t| typeof MANAGED_HOOK;\n\nexport interface EffectStore {\n\t/**\n\t * An enum defining how this hook is used and whether it is invoked in a\n\t * component's body or hook body. See the comment on `EffectStoreUsage` for\n\t * more details.\n\t */\n\treadonly _usage: EffectStoreUsage;\n\treadonly effect: Effect;\n\tsubscribe(onStoreChange: () => void): () => void;\n\tgetSnapshot(): number;\n\t/** startEffect - begin tracking signals used in this component */\n\t_start(): void;\n\t/** finishEffect - stop tracking the signals used in this component */\n\tf(): void;\n\t[symDispose](): void;\n}\n\nlet currentStore: EffectStore | undefined;\n\nfunction startComponentEffect(\n\tprevStore: EffectStore | undefined,\n\tnextStore: EffectStore\n) {\n\tconst endEffect = nextStore.effect._start();\n\tcurrentStore = nextStore;\n\n\treturn finishComponentEffect.bind(nextStore, prevStore, endEffect);\n}\n\nfunction finishComponentEffect(\n\tthis: EffectStore,\n\tprevStore: EffectStore | undefined,\n\tendEffect: () => void\n) {\n\tendEffect();\n\tcurrentStore = prevStore;\n}\n\n/**\n * A redux-like store whose store value is a positive 32bit integer (a\n * 'version').\n *\n * React subscribes to this store and gets a snapshot of the current 'version',\n * whenever the 'version' changes, we tell React it's time to update the\n * component (call 'onStoreChange').\n *\n * How we achieve this is by creating a binding with an 'effect', when the\n * `effect._callback' is called, we update our store version and tell React to\n * re-render the component ([1] We don't really care when/how React does it).\n *\n * [1]\n * @see https://react.dev/reference/react/useSyncExternalStore\n * @see\n * https://github.com/reactjs/rfcs/blob/main/text/0214-use-sync-external-store.md\n *\n * @param _usage An enum defining how this hook is used and whether it is\n * invoked in a component's body or hook body. See the comment on\n * `EffectStoreUsage` for more details.\n */\nfunction createEffectStore(_usage: EffectStoreUsage): EffectStore {\n\tlet effectInstance!: Effect;\n\tlet endEffect: (() => void) | undefined;\n\tlet version = 0;\n\tlet onChangeNotifyReact: (() => void) | undefined;\n\n\tlet unsubscribe = effect(function (this: Effect) {\n\t\teffectInstance = this;\n\t});\n\teffectInstance._callback = function () {\n\t\tversion = (version + 1) | 0;\n\t\tif (onChangeNotifyReact) onChangeNotifyReact();\n\t};\n\n\treturn {\n\t\t_usage,\n\t\teffect: effectInstance,\n\t\tsubscribe(onStoreChange) {\n\t\t\tonChangeNotifyReact = onStoreChange;\n\n\t\t\treturn function () {\n\t\t\t\t/**\n\t\t\t\t * Rotate to next version when unsubscribing to ensure that components are re-run\n\t\t\t\t * when subscribing again.\n\t\t\t\t *\n\t\t\t\t * In StrictMode, 'memo'-ed components seem to keep a stale snapshot version, so\n\t\t\t\t * don't re-run after subscribing again if the version is the same as last time.\n\t\t\t\t *\n\t\t\t\t * Because we unsubscribe from the effect, the version may not change. We simply\n\t\t\t\t * set a new initial version in case of stale snapshots here.\n\t\t\t\t */\n\t\t\t\tversion = (version + 1) | 0;\n\t\t\t\tonChangeNotifyReact = undefined;\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn version;\n\t\t},\n\t\t_start() {\n\t\t\t// In general, we want to support two kinds of usages of useSignals:\n\t\t\t//\n\t\t\t// A) Managed: calling useSignals in a component or hook body wrapped in a\n\t\t\t//    try/finally (like what the react-transform plugin does)\n\t\t\t//\n\t\t\t// B) Unmanaged: Calling useSignals directly without wrapping in a\n\t\t\t//    try/finally\n\t\t\t//\n\t\t\t// For managed, we finish the effect in the finally block of the component\n\t\t\t// or hook body. For unmanaged, we finish the effect in the next\n\t\t\t// useSignals call or after a microtask.\n\t\t\t//\n\t\t\t// There are different tradeoffs which each approach. With managed, using\n\t\t\t// a try/finally ensures that only signals used in the component or hook\n\t\t\t// body are tracked. However, signals accessed in render props are missed\n\t\t\t// because the render prop is invoked in another component that may or may\n\t\t\t// not realize it is rendering signals accessed in the render prop it is\n\t\t\t// given.\n\t\t\t//\n\t\t\t// The other approach is \"unmanaged\": to call useSignals directly without\n\t\t\t// wrapping in a try/finally. This approach is easier to manually write in\n\t\t\t// situations where a build step isn't available but does open up the\n\t\t\t// possibility of catching signals accessed in other code before the\n\t\t\t// effect is closed (e.g. in a layout effect). Most situations where this\n\t\t\t// could happen are generally consider bad patterns or bugs. For example,\n\t\t\t// using a signal in a component and not having a call to `useSignals`\n\t\t\t// would be an bug. Or using a signal in `useLayoutEffect` is generally\n\t\t\t// not recommended since that layout effect won't update when the signals'\n\t\t\t// value change.\n\t\t\t//\n\t\t\t// To support both approaches, we need to track how each invocation of\n\t\t\t// useSignals is used, so we can properly transition between different\n\t\t\t// kinds of usages.\n\t\t\t//\n\t\t\t// The following table shows the different scenarios and how we should\n\t\t\t// handle them.\n\t\t\t//\n\t\t\t// Key:\n\t\t\t// 0 = UNMANAGED\n\t\t\t// 1 = MANAGED_COMPONENT\n\t\t\t// 2 = MANAGED_HOOK\n\t\t\t//\n\t\t\t// Pattern:\n\t\t\t// prev store usage -> this store usage: action to take\n\t\t\t//\n\t\t\t// - 0 -> 0: finish previous effect (unknown to unknown)\n\t\t\t//\n\t\t\t//   We don't know how the previous effect was used, so we need to finish\n\t\t\t//   it before starting the next effect.\n\t\t\t//\n\t\t\t// - 0 -> 1: finish previous effect\n\t\t\t//\n\t\t\t//   Assume previous invocation was another component or hook from another\n\t\t\t//   component. Nested component renders (renderToStaticMarkup within a\n\t\t\t//   component's render) won't be supported with bare useSignals calls.\n\t\t\t//\n\t\t\t// - 0 -> 2: capture & restore\n\t\t\t//\n\t\t\t//   Previous invocation could be a component or a hook. Either way,\n\t\t\t//   restore it after our invocation so that it can continue to capture\n\t\t\t//   any signals after we exit.\n\t\t\t//\n\t\t\t// - 1 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 1 -> 1: capture & restore (e.g. component calls renderToStaticMarkup)\n\t\t\t// - 1 -> 2: capture & restore (e.g. hook)\n\t\t\t//\n\t\t\t// - 2 -> 0: Do nothing. Signals already captured by current effect store\n\t\t\t// - 2 -> 1: capture & restore (e.g. hook calls renderToStaticMarkup)\n\t\t\t// - 2 -> 2: capture & restore (e.g. nested hook calls)\n\n\t\t\tif (currentStore == undefined) {\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst prevUsage = currentStore._usage;\n\t\t\tconst thisUsage = this._usage;\n\n\t\t\tif (\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == UNMANAGED) || // 0 -> 0\n\t\t\t\t(prevUsage == UNMANAGED && thisUsage == MANAGED_COMPONENT) // 0 -> 1\n\t\t\t) {\n\t\t\t\t// finish previous effect\n\t\t\t\tcurrentStore.f();\n\t\t\t\tendEffect = startComponentEffect(undefined, this);\n\t\t\t} else if (\n\t\t\t\t(prevUsage == MANAGED_COMPONENT && thisUsage == UNMANAGED) || // 1 -> 0\n\t\t\t\t(prevUsage == MANAGED_HOOK && thisUsage == UNMANAGED) // 2 -> 0\n\t\t\t) {\n\t\t\t\t// Do nothing since it'll be captured by current effect store\n\t\t\t} else {\n\t\t\t\t// nested scenarios, so capture and restore the previous effect store\n\t\t\t\tendEffect = startComponentEffect(currentStore, this);\n\t\t\t}\n\t\t},\n\t\tf() {\n\t\t\tconst end = endEffect;\n\t\t\tendEffect = undefined;\n\t\t\tend?.();\n\t\t},\n\t\t[symDispose]() {\n\t\t\tthis.f();\n\t\t},\n\t};\n}\n\nconst noop = () => {};\n\nfunction createEmptyEffectStore(): EffectStore {\n\treturn {\n\t\t_usage: UNMANAGED,\n\t\teffect: {\n\t\t\t_sources: undefined,\n\t\t\t_callback() {},\n\t\t\t_start() {\n\t\t\t\treturn /* endEffect */ noop;\n\t\t\t},\n\t\t\t_dispose() {},\n\t\t},\n\t\tsubscribe() {\n\t\t\treturn /* unsubscribe */ noop;\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn 0;\n\t\t},\n\t\t_start() {},\n\t\tf() {},\n\t\t[symDispose]() {},\n\t};\n}\n\nconst emptyEffectStore = createEmptyEffectStore();\n\nconst _queueMicroTask = Promise.prototype.then.bind(Promise.resolve());\n\nlet finalCleanup: Promise<void> | undefined;\nexport function ensureFinalCleanup() {\n\tif (!finalCleanup) {\n\t\tfinalCleanup = _queueMicroTask(cleanupTrailingStore);\n\t}\n}\nfunction cleanupTrailingStore() {\n\tfinalCleanup = undefined;\n\tcurrentStore?.f();\n}\n\nconst useIsomorphicLayoutEffect =\n\ttypeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n/**\n * Custom hook to create the effect to track signals used during render and\n * subscribe to changes to rerender the component when the signals change.\n */\nexport function _useSignalsImplementation(\n\t_usage: EffectStoreUsage = UNMANAGED\n): EffectStore {\n\tensureFinalCleanup();\n\n\tconst storeRef = useRef<EffectStore>();\n\tif (storeRef.current == null) {\n\t\tif (typeof window === \"undefined\") {\n\t\t\tstoreRef.current = emptyEffectStore;\n\t\t} else {\n\t\t\tstoreRef.current = createEffectStore(_usage);\n\t\t}\n\t}\n\n\tconst store = storeRef.current;\n\tuseSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\tstore._start();\n\t// note: _usage is a constant here, so conditional is okay\n\tif (_usage === UNMANAGED) useIsomorphicLayoutEffect(cleanupTrailingStore);\n\n\treturn store;\n}\n\n/**\n * A wrapper component that renders a Signal's value directly as a Text node or JSX.\n */\nfunction SignalValue({ data }: { data: Signal }) {\n\tconst store = _useSignalsImplementation(1);\n\ttry {\n\t\treturn data.value;\n\t} finally {\n\t\tstore.f();\n\t}\n}\n\n// Decorate Signals so React renders them as <SignalValue> components.\nObject.defineProperties(Signal.prototype, {\n\t$$typeof: { configurable: true, value: ReactElemType },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\tref: { configurable: true, value: null },\n});\n\nexport function useSignals(usage?: EffectStoreUsage): EffectStore {\n\treturn _useSignalsImplementation(usage);\n}\n\nexport function useSignal<T>(value: T): Signal<T>;\nexport function useSignal<T = undefined>(): Signal<T | undefined>;\nexport function useSignal<T>(value?: T) {\n\treturn useMemo(() => signal<T | undefined>(value), Empty);\n}\n\nexport function useComputed<T>(compute: () => T): ReadonlySignal<T> {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\treturn useMemo(() => computed<T>(() => $compute.current()), Empty);\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(function (this: Effect) {\n\t\t\treturn callback.current();\n\t\t});\n\t}, Empty);\n}\n", "export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n", "import { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n", "import { nanoid } from 'nanoid';\n\nexport type StateEvent = Readonly<{\n  id: string;\n  type: string;\n  value: unknown;\n  accepted: boolean;\n  parentSignalId?: string;\n}>;\n\n/**\n * Creates a new state event type.\n */\ntype CreateStateEventType<V, T extends string, C extends Record<string, unknown> = Record<never, never>> = Readonly<{\n  type: T;\n  value: V;\n}> &\n  Readonly<C> &\n  StateEvent;\n\n/**\n * A state event received from the server describing the current state of the\n * signal.\n */\nexport type SnapshotStateEvent<T> = CreateStateEventType<T, 'snapshot'>;\n\n/**\n * A state event defines a new value of the signal shared with the server. The\n */\nexport type SetStateEvent<T> = CreateStateEventType<T, 'set'>;\n\nexport function createSetStateEvent<T>(value: T, signalId?: string, parentSignalId?: string): SetStateEvent<T> {\n  return {\n    id: signalId ?? nanoid(),\n    type: 'set',\n    value,\n    accepted: false,\n    ...(parentSignalId !== undefined ? { parentSignalId } : {}),\n  };\n}\n\nexport type ReplaceStateEvent<T> = CreateStateEventType<T, 'replace', { expected: T }>;\n\nexport function createReplaceStateEvent<T>(\n  expected: T,\n  value: T,\n  signalId?: string,\n  parentSignalId?: string,\n): ReplaceStateEvent<T> {\n  return {\n    id: signalId ?? nanoid(),\n    type: 'replace',\n    value,\n    expected,\n    accepted: false,\n    ...(parentSignalId !== undefined ? { parentSignalId } : {}),\n  };\n}\n\nexport type IncrementStateEvent = CreateStateEventType<number, 'increment'>;\n\nexport function createIncrementStateEvent(delta: number): IncrementStateEvent {\n  return {\n    id: nanoid(),\n    type: 'increment',\n    value: delta,\n    accepted: false,\n  };\n}\n\nexport type ListEntry<T> = Readonly<{\n  id: string;\n  prev?: string;\n  next?: string;\n  value: T;\n}>;\n\nexport type ListSnapshotStateEvent<T> = CreateStateEventType<never, 'snapshot', { entries: Array<ListEntry<T>> }>;\n\nexport type InsertLastStateEvent<T> = CreateStateEventType<T, 'insert', { position: 'last'; entryId?: string }>;\n\nexport function createInsertLastStateEvent<T>(value: T): InsertLastStateEvent<T> {\n  return {\n    id: nanoid(),\n    type: 'insert',\n    value,\n    position: 'last',\n    accepted: false,\n  };\n}\n\nexport type RemoveStateEvent = CreateStateEventType<never, 'remove', { entryId: string }>;\n\nexport function createRemoveStateEvent(entryId: string): RemoveStateEvent {\n  return {\n    id: nanoid(),\n    type: 'remove',\n    entryId,\n    value: undefined as never,\n    accepted: false,\n  };\n}\n\nfunction isStateEvent(event: unknown): event is StateEvent {\n  return (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as { id?: unknown }).id === 'string' &&\n    typeof (event as { type?: unknown }).type === 'string' &&\n    typeof (event as { value?: unknown }).value !== 'undefined' &&\n    typeof (event as { accepted?: unknown }).accepted === 'boolean'\n  );\n}\n\nexport function isSnapshotStateEvent<T>(event: unknown): event is SnapshotStateEvent<T> {\n  return isStateEvent(event) && event.type === 'snapshot';\n}\n\nexport function isSetStateEvent<T>(event: unknown): event is SetStateEvent<T> {\n  return isStateEvent(event) && event.type === 'set';\n}\n\nexport function isReplaceStateEvent<T>(event: unknown): event is ReplaceStateEvent<T> {\n  return (\n    isStateEvent(event) && typeof (event as { expected?: unknown }).expected !== 'undefined' && event.type === 'replace'\n  );\n}\n\nexport function isIncrementStateEvent(event: unknown): event is IncrementStateEvent {\n  return isStateEvent(event) && event.type === 'increment';\n}\n\nexport function isListSnapshotStateEvent<T>(event: unknown): event is ListSnapshotStateEvent<T> {\n  return (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as { id?: unknown }).id === 'string' &&\n    (event as { type?: unknown }).type === 'snapshot' &&\n    (event as { entries?: unknown }).entries instanceof Array &&\n    typeof (event as { accepted?: unknown }).accepted !== 'undefined'\n  );\n}\n\nexport function isInsertLastStateEvent<T>(event: unknown): event is InsertLastStateEvent<T> {\n  return isStateEvent(event) && event.type === 'insert' && (event as { position?: unknown }).position === 'last';\n}\n\nexport function isRemoveStateEvent(event: unknown): event is RemoveStateEvent {\n  return (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as { id?: unknown }).id === 'string' &&\n    (event as { type?: unknown }).type === 'remove' &&\n    typeof (event as { entryId?: unknown }).entryId === 'string' &&\n    typeof (event as { value?: unknown }).value === 'undefined'\n  );\n}\n", "import type { ActionOnLostSubscription, ConnectClient, Subscription } from '@vaadin/hilla-frontend';\nimport { nanoid } from 'nanoid';\nimport { computed, signal, Signal } from './core.js';\nimport { createSetStateEvent, type StateEvent } from './events.js';\n\nconst ENDPOINT = 'SignalsHandler';\n\n/**\n * A return type for signal operations that exposes a `result` property of type\n * `Promise`, that resolves when the operation is completed. It allows defining\n * callbacks to be run after the operation is completed, or error handling when\n * the operation fails.\n *\n * @example\n * ```ts\n * const sharedName = NameService.sharedName({ defaultValue: '' });\n * sharedName.replace('John').result\n *    .then(() => console.log('Name updated successfully'))\n *    .catch((error) => console.error('Failed to update the name:', error));\n * ```\n */\nexport interface Operation {\n  result: Promise<void>;\n}\n\n/**\n * An abstraction of a signal that tracks the number of subscribers, and calls\n * the provided `onSubscribe` and `onUnsubscribe` callbacks for the first\n * subscription and the last unsubscription, respectively.\n * @internal\n */\nexport abstract class DependencyTrackingSignal<T> extends Signal<T> {\n  readonly #onFirstSubscribe: () => void;\n  readonly #onLastUnsubscribe: () => void;\n\n  // -1 means to ignore the first subscription that is created internally in the\n  // FullStackSignal constructor.\n  #subscribeCount = -1;\n\n  protected constructor(value: T | undefined, onFirstSubscribe: () => void, onLastUnsubscribe: () => void) {\n    super(value);\n    this.#onFirstSubscribe = onFirstSubscribe;\n    this.#onLastUnsubscribe = onLastUnsubscribe;\n  }\n\n  protected override S(node: unknown): void {\n    super.S(node);\n    if (this.#subscribeCount === 0) {\n      this.#onFirstSubscribe();\n    }\n    this.#subscribeCount += 1;\n  }\n\n  protected override U(node: unknown): void {\n    super.U(node);\n    this.#subscribeCount -= 1;\n    if (this.#subscribeCount === 0) {\n      this.#onLastUnsubscribe();\n    }\n  }\n}\n\n/**\n * An object that describes a data object to connect to the signal provider\n * service.\n */\nexport type ServerConnectionConfig = Readonly<{\n  /**\n   * The client instance to be used for communication.\n   */\n  client: ConnectClient;\n\n  /**\n   * The name of the signal provider service endpoint.\n   */\n  endpoint: string;\n\n  /**\n   * The name of the signal provider service method.\n   */\n  method: string;\n\n  /**\n   * Optional object with method call arguments to be sent to the endpoint\n   * method that provides the signal when subscribing to it.\n   */\n  params?: Record<string, unknown>;\n\n  /**\n   * The unique identifier of the parent signal in the client.\n   */\n  parentClientSignalId?: string;\n}>;\n\n/**\n * A server connection manager.\n */\nclass ServerConnection {\n  readonly #id: string;\n  readonly config: ServerConnectionConfig;\n  #subscription?: Subscription<StateEvent>;\n\n  constructor(id: string, config: ServerConnectionConfig) {\n    this.config = config;\n    this.#id = id;\n  }\n\n  get subscription() {\n    return this.#subscription;\n  }\n\n  connect() {\n    const { client, endpoint, method, params, parentClientSignalId } = this.config;\n\n    this.#subscription ??= client.subscribe(ENDPOINT, 'subscribe', {\n      providerEndpoint: endpoint,\n      providerMethod: method,\n      clientSignalId: this.#id,\n      params,\n      parentClientSignalId,\n    });\n\n    return this.#subscription;\n  }\n\n  async update(event: StateEvent): Promise<void> {\n    const onTheFly = !this.#subscription;\n\n    if (onTheFly) {\n      this.connect();\n    }\n\n    await this.config.client.call(ENDPOINT, 'update', {\n      clientSignalId: this.#id,\n      event,\n    });\n\n    if (onTheFly) {\n      this.disconnect();\n    }\n  }\n\n  disconnect() {\n    this.#subscription?.cancel();\n    this.#subscription = undefined;\n  }\n}\n\nexport const $update = Symbol('update');\nexport const $processServerResponse = Symbol('processServerResponse');\nexport const $setValueQuietly = Symbol('setValueQuietly');\nexport const $resolveOperation = Symbol('resolveOperation');\nexport const $createOperation = Symbol('createOperation');\n\n/**\n * A signal that holds a shared value. Each change to the value is propagated to\n * the server-side signal provider. At the same time, each change received from\n * the server-side signal provider is propagated to the local signal and it's\n * subscribers.\n *\n * @internal\n */\nexport abstract class FullStackSignal<T> extends DependencyTrackingSignal<T> {\n  /**\n   * The unique identifier of the signal necessary to communicate with the\n   * server.\n   */\n  readonly id: string;\n\n  /**\n   * The server connection manager.\n   */\n  readonly server: ServerConnection;\n\n  /**\n   * Defines whether the signal is currently awaits a server-side response.\n   */\n  readonly pending = computed(() => this.#pending.value);\n\n  /**\n   * Defines whether the signal has an error.\n   */\n  readonly error = computed(() => this.#error.value);\n\n  readonly #pending = signal(false);\n  readonly #error = signal<Error | undefined>(undefined);\n\n  // Paused at the very start to prevent the signal from sending the initial\n  // value to the server.\n  #paused = true;\n\n  constructor(value: T | undefined, config: ServerConnectionConfig, id?: string) {\n    super(\n      value,\n      () => this.#connect(),\n      () => this.#disconnect(),\n    );\n    this.id = id ?? nanoid();\n    this.server = new ServerConnection(this.id, config);\n\n    this.subscribe((v) => {\n      if (!this.#paused) {\n        this.#pending.value = true;\n        this.#error.value = undefined;\n        // For internal signals, the provided non-null to the constructor should\n        // be used along with the parent client side signal id when sending the\n        // set event to the server. For internal signals this combination is\n        // needed for addressing the correct parent/child signal instances on\n        // the server. For a standalone signal, both of them should be passed in\n        // as undefined:\n        const signalId = config.parentClientSignalId !== undefined ? this.id : undefined;\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this[$update](createSetStateEvent(v, signalId, config.parentClientSignalId));\n      }\n    });\n\n    this.#paused = false;\n  }\n\n  // stores the promise handlers associated to operations\n  readonly #operationPromises = new Map<\n    string,\n    {\n      resolve(value: PromiseLike<void> | void): void;\n      reject(reason?: any): void;\n    }\n  >();\n\n  // creates the object to be returned by operations to allow defining callbacks\n  protected [$createOperation]({ id, promise }: { id?: string; promise?: Promise<void> }): Operation {\n    const thens = this.#operationPromises;\n    const promises: Array<Promise<void>> = [];\n\n    if (promise) {\n      // Add the provided promise to the list of promises\n      promises.push(promise);\n    }\n\n    if (id) {\n      // Create a promise to be associated to the provided id\n      promises.push(\n        new Promise<void>((resolve, reject) => {\n          thens.set(id, { resolve, reject });\n        }),\n      );\n    }\n\n    if (promises.length === 0) {\n      // If no promises were added, return a resolved promise\n      promises.push(Promise.resolve());\n    }\n\n    return {\n      result: Promise.allSettled(promises).then((results) => {\n        const lastResult = results[results.length - 1];\n        if (lastResult.status === 'fulfilled') {\n          return undefined;\n        }\n        throw lastResult.reason;\n      }),\n    };\n  }\n\n  /**\n   * Sets the local value of the signal without sending any events to the server\n   * @param value - The new value.\n   * @internal\n   */\n  protected [$setValueQuietly](value: T): void {\n    this.#paused = true;\n    super.value = value;\n    this.#paused = false;\n  }\n\n  /**\n   * A method to update the server with the new value.\n   *\n   * @param event - The event to update the server with.\n   * @returns The server response promise.\n   */\n  protected async [$update](event: StateEvent): Promise<void> {\n    return this.server\n      .update(event)\n      .catch((error: unknown) => {\n        this.#error.value = error instanceof Error ? error : new Error(String(error));\n      })\n      .finally(() => {\n        this.#pending.value = false;\n      });\n  }\n\n  /**\n   * Resolves the operation promise associated with the given event id.\n   *\n   * @param eventId - The event id.\n   * @param reason - The reason to reject the promise (if any).\n   */\n  protected [$resolveOperation](eventId: string, reason?: string): void {\n    const operationPromise = this.#operationPromises.get(eventId);\n    if (operationPromise) {\n      this.#operationPromises.delete(eventId);\n      if (reason) {\n        operationPromise.reject(reason);\n      } else {\n        operationPromise.resolve();\n      }\n    }\n  }\n\n  /**\n   * A method with to process the server response. The implementation is\n   * specific for each signal type.\n   *\n   * @param event - The server response event.\n   */\n  protected abstract [$processServerResponse](event: StateEvent): void;\n\n  #connect() {\n    this.server\n      .connect()\n      .onSubscriptionLost(() => 'resubscribe' as ActionOnLostSubscription)\n      .onNext((event: StateEvent) => {\n        this.#paused = true;\n        this[$processServerResponse](event);\n        this.#paused = false;\n      });\n  }\n\n  #disconnect() {\n    if (this.server.subscription === undefined) {\n      return;\n    }\n    this.server.disconnect();\n  }\n}\n", "import { nanoid } from 'nanoid';\nimport {\n  createReplaceStateEvent,\n  createSetStateEvent,\n  isReplaceStateEvent,\n  isSetStateEvent,\n  isSnapshotStateEvent,\n  type StateEvent,\n} from './events.js';\nimport {\n  $createOperation,\n  $processServerResponse,\n  $resolveOperation,\n  $setValueQuietly,\n  $update,\n  FullStackSignal,\n  type Operation,\n} from './FullStackSignal.js';\n\ntype PendingRequestsRecord<T> = Readonly<{\n  id: string;\n  callback(value: T): T;\n}> & { canceled: boolean };\n\n/**\n * An operation subscription that can be canceled.\n */\nexport interface OperationSubscription extends Operation {\n  cancel(): void;\n}\n\n/**\n * A full-stack signal that holds an arbitrary value.\n */\nexport class ValueSignal<T> extends FullStackSignal<T> {\n  readonly #pendingRequests = new Map<string, PendingRequestsRecord<T>>();\n\n  /**\n   * Sets the value.\n   * Note that the value change event that is propagated to the server as the\n   * result of this operation is not taking the last seen value into account and\n   * will overwrite the shared value on the server unconditionally (AKA: \"Last\n   * Write Wins\"). If you need to perform a conditional update, use the\n   * `replace` method instead.\n   *\n   * @param value - The new value.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  set(value: T): Operation {\n    const { parentClientSignalId } = this.server.config;\n    const signalId = parentClientSignalId !== undefined ? this.id : undefined;\n    const event = createSetStateEvent(value, signalId, parentClientSignalId);\n    const promise = this[$update](event);\n    this[$setValueQuietly](value);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Replaces the value with a new one only if the current value is equal to the\n   * expected value.\n   *\n   * @param expected - The expected value.\n   * @param newValue - The new value.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  replace(expected: T, newValue: T): Operation {\n    const { parentClientSignalId } = this.server.config;\n    const signalId = parentClientSignalId !== undefined ? this.id : undefined;\n    const event = createReplaceStateEvent(expected, newValue, signalId, parentClientSignalId);\n    const promise = this[$update](event);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Tries to update the value by applying the callback function to the current\n   * value. In case of a concurrent change, the callback is run again with an\n   * updated input value. This is repeated until the result can be applied\n   * without concurrent changes, or the operation is canceled.\n   *\n   * Note that there is no guarantee that cancel() will be effective always,\n   * since a succeeding operation might already be on its way to the server.\n   *\n   * @param callback - The function that is applied on the current value to\n   *                   produce the new value.\n   * @returns An operation object that allows to perform additional actions,\n   *                   including cancellation.\n   */\n  update(callback: (value: T) => T): OperationSubscription {\n    const newValue = callback(this.value);\n    const event = createReplaceStateEvent(this.value, newValue);\n    const promise = this[$update](event);\n    const pendingRequest = { id: nanoid(), callback, canceled: false };\n    this.#pendingRequests.set(event.id, pendingRequest);\n    return {\n      ...this[$createOperation]({ id: pendingRequest.id, promise }),\n      cancel: () => {\n        pendingRequest.canceled = true;\n      },\n    };\n  }\n\n  protected override [$processServerResponse](event: StateEvent): void {\n    const record = this.#pendingRequests.get(event.id);\n    if (record) {\n      this.#pendingRequests.delete(event.id);\n\n      if (!(event.accepted || record.canceled)) {\n        this.update(record.callback);\n      }\n    }\n\n    let reason: string | undefined;\n    if (event.accepted || isSnapshotStateEvent<T>(event)) {\n      this.#applyAcceptedEvent(event);\n    } else {\n      reason = `Server rejected the operation with id '${event.id}'. See the server log for more details.`;\n    }\n    // `then` callbacks can be associated to the record or the event\n    // it depends on the operation that was performed\n    [record?.id, event.id].filter(Boolean).forEach((id) => this[$resolveOperation](id!, reason));\n  }\n\n  #applyAcceptedEvent(event: StateEvent): void {\n    if (isSetStateEvent<T>(event) || isSnapshotStateEvent<T>(event)) {\n      this.value = event.value;\n    } else if (isReplaceStateEvent<T>(event)) {\n      if (JSON.stringify(this.value) === JSON.stringify(event.expected)) {\n        this.value = event.value;\n      }\n    }\n  }\n}\n", "import { createIncrementStateEvent, isIncrementStateEvent, type StateEvent } from './events.js';\nimport {\n  $createOperation,\n  $processServerResponse,\n  $resolveOperation,\n  $setValueQuietly,\n  $update,\n  type Operation,\n} from './FullStackSignal.js';\nimport { ValueSignal } from './ValueSignal.js';\n\n/**\n * A signal that holds a number value. The underlying\n * value of this signal is stored and updated as a\n * shared value on the server.\n *\n * After obtaining the NumberSignal instance from\n * a server-side service that returns one, the value\n * can be updated using the `value` property,\n * and it can be read with or without the\n * `value` property (similar to a normal signal):\n *\n * @example\n * ```tsx\n * const counter = CounterService.counter();\n *\n * return (\n *    <Button onClick={() => counter.incrementBy(1)}>\n *      Click count: { counter }\n *    </Button>\n *    <Button onClick={() => counter.value = 0}>Reset</Button>\n * );\n * ```\n */\nexport class NumberSignal extends ValueSignal<number> {\n  readonly #sentIncrementEvents = new Map<string, StateEvent>();\n  /**\n   * Increments the value by the specified delta. The delta can be negative to\n   * decrease the value.\n   *\n   * This method differs from using the `++` or `+=` operators directly on the\n   * signal value. It performs an atomic operation to prevent conflicts from\n   * concurrent changes, ensuring that other users' modifications are not\n   * accidentally overwritten.\n   *\n   * @param delta - The delta to increment the value by. The delta can be\n   * negative.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  incrementBy(delta: number): Operation {\n    if (delta === 0) {\n      return { result: Promise.resolve() };\n    }\n    this[$setValueQuietly](this.value + delta);\n    const event = createIncrementStateEvent(delta);\n    this.#sentIncrementEvents.set(event.id, event);\n    const promise = this[$update](event);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  protected override [$processServerResponse](event: StateEvent): void {\n    if (event.accepted && isIncrementStateEvent(event)) {\n      const sentEvent = this.#sentIncrementEvents.get(event.id);\n      if (sentEvent) {\n        this.#sentIncrementEvents.delete(event.id);\n      } else {\n        this[$setValueQuietly](this.value + event.value);\n      }\n      this[$resolveOperation](event.id);\n    } else {\n      super[$processServerResponse](event);\n    }\n  }\n}\n", "import { FullStackSignal } from './FullStackSignal.js';\n\n/**\n * A {@link FullStackSignal} that represents a collection of values.\n *\n * @typeParam T - The type of the values in the collection.\n */\nexport abstract class CollectionSignal<T> extends FullStackSignal<T> {\n  override get value(): T {\n    return super.value;\n  }\n\n  /**\n   * @readonly\n   */\n  override set value(_: never) {\n    throw new Error('Value of the collection signals cannot be set.');\n  }\n}\n", "import { CollectionSignal } from './CollectionSignal.js';\nimport {\n  createInsertLastStateEvent,\n  createRemoveStateEvent,\n  type InsertLastStateEvent,\n  isInsertLastStateEvent,\n  isListSnapshotStateEvent,\n  isRemoveStateEvent,\n  type ListSnapshotStateEvent,\n  type RemoveStateEvent,\n  type StateEvent,\n} from './events.js';\nimport {\n  $createOperation,\n  $processServerResponse,\n  $resolveOperation,\n  $setValueQuietly,\n  $update,\n  type Operation,\n  type ServerConnectionConfig,\n} from './FullStackSignal.js';\nimport { ValueSignal } from './ValueSignal.js';\n\ntype EntryId = string;\ntype Entry<T> = {\n  id: EntryId;\n  value: ValueSignal<T>;\n  next?: EntryId;\n  prev?: EntryId;\n};\n\n/**\n * A {@link FullStackSignal} that represents a shared list of values, where each\n * value is represented by a {@link ValueSignal}.\n * The list can be modified by calling the defined methods to insert or remove\n * items, but the `value` property of a `ListSignal` instance is read-only and\n * cannot be assigned directly.\n * The value of each item in the list can be manipulated similar to a regular\n * {@link ValueSignal}.\n *\n * @typeParam T - The type of the values in the list.\n */\nexport class ListSignal<T> extends CollectionSignal<ReadonlyArray<ValueSignal<T>>> {\n  #head?: EntryId;\n  #tail?: EntryId;\n\n  readonly #values = new Map<string, Entry<T>>();\n\n  constructor(config: ServerConnectionConfig) {\n    const initialValue: Array<ValueSignal<T>> = [];\n    super(initialValue, config);\n  }\n\n  #computeItems(): ReadonlyArray<ValueSignal<T>> {\n    let current = this.#head;\n    const result: Array<ValueSignal<T>> = [];\n    while (current !== undefined) {\n      const entry = this.#values.get(current)!;\n      result.push(entry.value);\n      current = entry.next;\n    }\n    return result;\n  }\n\n  protected override [$processServerResponse](event: StateEvent): void {\n    if (!event.accepted) {\n      this[$resolveOperation](\n        event.id,\n        `Server rejected the operation with id '${event.id}'. See the server log for more details.`,\n      );\n      return;\n    }\n    if (isListSnapshotStateEvent<T>(event)) {\n      this.#handleSnapshotEvent(event);\n    } else if (isInsertLastStateEvent<T>(event)) {\n      this.#handleInsertLastUpdate(event);\n    } else if (isRemoveStateEvent(event)) {\n      this.#handleRemoveUpdate(event);\n    }\n    this[$resolveOperation](event.id);\n  }\n\n  #handleInsertLastUpdate(event: InsertLastStateEvent<T>): void {\n    if (event.entryId === undefined) {\n      throw new Error('Unexpected state: Entry id should be defined when insert last event is accepted');\n    }\n    const valueSignal = new ValueSignal<T>(\n      event.value,\n      { ...this.server.config, parentClientSignalId: this.id },\n      event.entryId,\n    );\n    const newEntry: Entry<T> = { id: valueSignal.id, value: valueSignal };\n\n    if (this.#head === undefined) {\n      this.#head = newEntry.id;\n      this.#tail = this.#head;\n    } else {\n      const tailEntry = this.#values.get(this.#tail!)!;\n      tailEntry.next = newEntry.id;\n      newEntry.prev = this.#tail;\n      this.#tail = newEntry.id;\n    }\n    this.#values.set(valueSignal.id, newEntry);\n    this[$setValueQuietly](this.#computeItems());\n  }\n\n  #handleRemoveUpdate(event: RemoveStateEvent): void {\n    const entryToRemove = this.#values.get(event.entryId);\n    if (entryToRemove === undefined) {\n      return;\n    }\n    this.#values.delete(event.id);\n    if (this.#head === entryToRemove.id) {\n      if (entryToRemove.next === undefined) {\n        this.#head = undefined;\n        this.#tail = undefined;\n      } else {\n        const newHead = this.#values.get(entryToRemove.next)!;\n        this.#head = newHead.id;\n        newHead.prev = undefined;\n      }\n    } else {\n      const prevEntry = this.#values.get(entryToRemove.prev!)!;\n      const nextEntry = entryToRemove.next !== undefined ? this.#values.get(entryToRemove.next) : undefined;\n      if (nextEntry === undefined) {\n        this.#tail = prevEntry.id;\n        prevEntry.next = undefined;\n      } else {\n        prevEntry.next = nextEntry.id;\n        nextEntry.prev = prevEntry.id;\n      }\n    }\n    this[$setValueQuietly](this.#computeItems());\n  }\n\n  #handleSnapshotEvent(event: ListSnapshotStateEvent<T>): void {\n    event.entries.forEach((entry) => {\n      this.#values.set(entry.id, {\n        id: entry.id,\n        prev: entry.prev,\n        next: entry.next,\n        value: new ValueSignal(entry.value, { ...this.server.config, parentClientSignalId: this.id }, entry.id),\n      });\n      if (entry.prev === undefined) {\n        this.#head = entry.id;\n      }\n      if (entry.next === undefined) {\n        this.#tail = entry.id;\n      }\n    });\n    this[$setValueQuietly](this.#computeItems());\n  }\n\n  /**\n   * Inserts a new value at the end of the list.\n   * @param value - The value to insert.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  insertLast(value: T): Operation {\n    const event = createInsertLastStateEvent(value);\n    const promise = this[$update](event);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Removes the given item from the list.\n   * @param item - The item to remove.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  remove(item: ValueSignal<T>): Operation {\n    const entryToRemove = this.#values.get(item.id);\n    if (entryToRemove === undefined) {\n      return { result: Promise.resolve() };\n    }\n    const removeEvent = createRemoveStateEvent(entryToRemove.value.id);\n    const promise = this[$update](removeEvent);\n    return this[$createOperation]({ id: removeEvent.id, promise });\n  }\n}\n"],
  "mappings": "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",
  "names": ["x", "y", "BRAND_SYMBOL", "Symbol", "endBatch", "batchDepth", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "_nextBatchedEffect", "_flags", "needsToRecompute", "_callback", "err", "batch", "fn", "evalContext", "untracked", "prevContext", "globalVersion", "addDependency", "signal", "node", "_node", "_target", "_version", "_source", "_prevSource", "_sources", "_nextSource", "_prevTarget", "_nextTarget", "_rollbackNode", "_subscribe", "Signal", "value", "this", "_value", "_targets", "prototype", "brand", "_refresh", "_unsubscribe", "prev", "subscribe", "_this", "valueOf", "toString", "toJSON", "peek", "Object", "defineProperty", "get", "set", "Error", "_notify", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "Computed", "call", "undefined", "_fn", "_globalVersion", "OUTDATED", "computed", "cleanupEffect", "cleanup", "_cleanup", "disposeEffect", "endEffect", "Effect", "finish", "_start", "bind", "_dispose", "major", "reactVersion", "split", "map", "Number", "Empty", "ReactElemType", "Symbol", "currentStore", "symDispose", "Symbol", "dispose", "startComponentEffect", "prevStore", "nextStore", "endEffect", "effect", "_start", "finishComponentEffect", "bind", "_ref2", "finalCleanup", "noop", "emptyEffectStore", "_usage", "_sources", "_callback", "_dispose", "subscribe", "getSnapshot", "f", "_queueMicroTask", "Promise", "prototype", "then", "resolve", "ensureFinalCleanup", "cleanupTrailingStore", "_currentStore", "useIsomorphicLayoutEffect", "window", "useLayoutEffect", "useEffect", "_useSignalsImplementation", "storeRef", "useRef", "current", "_ref", "effectInstance", "onChangeNotifyReact", "version", "unsubscribe", "this", "onStoreChange", "undefined", "prevUsage", "thisUsage", "end", "store", "useSyncExternalStore", "Object", "defineProperties", "Signal", "$$typeof", "configurable", "value", "ReactElemType", "type", "_ref3", "data", "props", "get", "ref", "useSignal", "value", "useMemo", "signal", "Empty", "useComputed", "compute", "$compute", "useRef", "current", "computed", "useSignalEffect", "cb", "callback", "useEffect", "effect", "v", "_"]
}
