import {
  require_react
} from "./chunk-IF5A3MEL.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-547O27LD.js";

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is(x2, y3) {
        return x2 === y3 && (0 !== x2 || 1 / x2 === 1 / y3) || x2 !== x2 && y3 !== y3;
      }
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/@vaadin/hilla-react-signals/polyfills.js
if (!("withResolvers" in Promise)) {
  Object.defineProperty(Promise, "withResolvers", {
    configurable: true,
    value() {
      let resolve;
      let reject;
      const promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
      });
      return { resolve, reject, promise };
    }
  });
}

// node_modules/@preact/signals-core/dist/signals-core.module.js
var i = Symbol.for("preact-signals");
function t() {
  if (!(s > 1)) {
    var i2, t2 = false;
    while (void 0 !== h) {
      var r2 = h;
      h = void 0;
      f++;
      while (void 0 !== r2) {
        var o3 = r2.o;
        r2.o = void 0;
        r2.f &= -3;
        if (!(8 & r2.f) && c(r2)) try {
          r2.c();
        } catch (r3) {
          if (!t2) {
            i2 = r3;
            t2 = true;
          }
        }
        r2 = o3;
      }
    }
    f = 0;
    s--;
    if (t2) throw i2;
  } else s--;
}
function r(i2) {
  if (s > 0) return i2();
  s++;
  try {
    return i2();
  } finally {
    t();
  }
}
var o = void 0;
function n(i2) {
  var t2 = o;
  o = void 0;
  try {
    return i2();
  } finally {
    o = t2;
  }
}
var h = void 0;
var s = 0;
var f = 0;
var v = 0;
function e(i2) {
  if (void 0 !== o) {
    var t2 = i2.n;
    if (void 0 === t2 || t2.t !== o) {
      t2 = { i: 0, S: i2, p: o.s, n: void 0, t: o, e: void 0, x: void 0, r: t2 };
      if (void 0 !== o.s) o.s.n = t2;
      o.s = t2;
      i2.n = t2;
      if (32 & o.f) i2.S(t2);
      return t2;
    } else if (-1 === t2.i) {
      t2.i = 0;
      if (void 0 !== t2.n) {
        t2.n.p = t2.p;
        if (void 0 !== t2.p) t2.p.n = t2.n;
        t2.p = o.s;
        t2.n = void 0;
        o.s.n = t2;
        o.s = t2;
      }
      return t2;
    }
  }
}
function u(i2) {
  this.v = i2;
  this.i = 0;
  this.n = void 0;
  this.t = void 0;
}
u.prototype.brand = i;
u.prototype.h = function() {
  return true;
};
u.prototype.S = function(i2) {
  if (this.t !== i2 && void 0 === i2.e) {
    i2.x = this.t;
    if (void 0 !== this.t) this.t.e = i2;
    this.t = i2;
  }
};
u.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    var t2 = i2.e, r2 = i2.x;
    if (void 0 !== t2) {
      t2.x = r2;
      i2.e = void 0;
    }
    if (void 0 !== r2) {
      r2.e = t2;
      i2.x = void 0;
    }
    if (i2 === this.t) this.t = r2;
  }
};
u.prototype.subscribe = function(i2) {
  var t2 = this;
  return E(function() {
    var r2 = t2.value, n2 = o;
    o = void 0;
    try {
      i2(r2);
    } finally {
      o = n2;
    }
  });
};
u.prototype.valueOf = function() {
  return this.value;
};
u.prototype.toString = function() {
  return this.value + "";
};
u.prototype.toJSON = function() {
  return this.value;
};
u.prototype.peek = function() {
  var i2 = o;
  o = void 0;
  try {
    return this.value;
  } finally {
    o = i2;
  }
};
Object.defineProperty(u.prototype, "value", { get: function() {
  var i2 = e(this);
  if (void 0 !== i2) i2.i = this.i;
  return this.v;
}, set: function(i2) {
  if (i2 !== this.v) {
    if (f > 100) throw new Error("Cycle detected");
    this.v = i2;
    this.i++;
    v++;
    s++;
    try {
      for (var r2 = this.t; void 0 !== r2; r2 = r2.x) r2.t.N();
    } finally {
      t();
    }
  }
} });
function d(i2) {
  return new u(i2);
}
function c(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) if (t2.S.i !== t2.i || !t2.S.h() || t2.S.i !== t2.i) return true;
  return false;
}
function a(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) {
    var r2 = t2.S.n;
    if (void 0 !== r2) t2.r = r2;
    t2.S.n = t2;
    t2.i = -1;
    if (void 0 === t2.n) {
      i2.s = t2;
      break;
    }
  }
}
function l(i2) {
  var t2 = i2.s, r2 = void 0;
  while (void 0 !== t2) {
    var o3 = t2.p;
    if (-1 === t2.i) {
      t2.S.U(t2);
      if (void 0 !== o3) o3.n = t2.n;
      if (void 0 !== t2.n) t2.n.p = o3;
    } else r2 = t2;
    t2.S.n = t2.r;
    if (void 0 !== t2.r) t2.r = void 0;
    t2 = o3;
  }
  i2.s = r2;
}
function y(i2) {
  u.call(this, void 0);
  this.x = i2;
  this.s = void 0;
  this.g = v - 1;
  this.f = 4;
}
(y.prototype = new u()).h = function() {
  this.f &= -3;
  if (1 & this.f) return false;
  if (32 == (36 & this.f)) return true;
  this.f &= -5;
  if (this.g === v) return true;
  this.g = v;
  this.f |= 1;
  if (this.i > 0 && !c(this)) {
    this.f &= -2;
    return true;
  }
  var i2 = o;
  try {
    a(this);
    o = this;
    var t2 = this.x();
    if (16 & this.f || this.v !== t2 || 0 === this.i) {
      this.v = t2;
      this.f &= -17;
      this.i++;
    }
  } catch (i3) {
    this.v = i3;
    this.f |= 16;
    this.i++;
  }
  o = i2;
  l(this);
  this.f &= -2;
  return true;
};
y.prototype.S = function(i2) {
  if (void 0 === this.t) {
    this.f |= 36;
    for (var t2 = this.s; void 0 !== t2; t2 = t2.n) t2.S.S(t2);
  }
  u.prototype.S.call(this, i2);
};
y.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    u.prototype.U.call(this, i2);
    if (void 0 === this.t) {
      this.f &= -33;
      for (var t2 = this.s; void 0 !== t2; t2 = t2.n) t2.S.U(t2);
    }
  }
};
y.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var i2 = this.t; void 0 !== i2; i2 = i2.x) i2.t.N();
  }
};
Object.defineProperty(y.prototype, "value", { get: function() {
  if (1 & this.f) throw new Error("Cycle detected");
  var i2 = e(this);
  this.h();
  if (void 0 !== i2) i2.i = this.i;
  if (16 & this.f) throw this.v;
  return this.v;
} });
function w(i2) {
  return new y(i2);
}
function _(i2) {
  var r2 = i2.u;
  i2.u = void 0;
  if ("function" == typeof r2) {
    s++;
    var n2 = o;
    o = void 0;
    try {
      r2();
    } catch (t2) {
      i2.f &= -2;
      i2.f |= 8;
      g(i2);
      throw t2;
    } finally {
      o = n2;
      t();
    }
  }
}
function g(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) t2.S.U(t2);
  i2.x = void 0;
  i2.s = void 0;
  _(i2);
}
function p(i2) {
  if (o !== this) throw new Error("Out-of-order effect");
  l(this);
  o = i2;
  this.f &= -2;
  if (8 & this.f) g(this);
  t();
}
function b(i2) {
  this.x = i2;
  this.u = void 0;
  this.s = void 0;
  this.o = void 0;
  this.f = 32;
}
b.prototype.c = function() {
  var i2 = this.S();
  try {
    if (8 & this.f) return;
    if (void 0 === this.x) return;
    var t2 = this.x();
    if ("function" == typeof t2) this.u = t2;
  } finally {
    i2();
  }
};
b.prototype.S = function() {
  if (1 & this.f) throw new Error("Cycle detected");
  this.f |= 1;
  this.f &= -9;
  _(this);
  a(this);
  s++;
  var i2 = o;
  o = this;
  return p.bind(this, i2);
};
b.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 2;
    this.o = h;
    h = this;
  }
};
b.prototype.d = function() {
  this.f |= 8;
  if (!(1 & this.f)) g(this);
};
function E(i2) {
  var t2 = new b(i2);
  try {
    t2.c();
  } catch (i3) {
    t2.d();
    throw i3;
  }
  return t2.d.bind(t2);
}

// node_modules/@preact/signals-react/runtime/dist/runtime.module.js
var import_react = __toESM(require_react());
var import_shim = __toESM(require_shim());
var s2 = import_react.version.split(".").map(Number)[0];
var l2 = [];
var v2 = Symbol.for(s2 >= 19 ? "react.transitional.element" : "react.element");
var p2;
var m = Symbol.dispose || Symbol.for("Symbol.dispose");
function b2(n2, t2) {
  var r2 = t2.effect.S();
  p2 = t2;
  return y2.bind(t2, n2, r2);
}
function y2(n2, t2) {
  t2();
  p2 = n2;
}
var g2;
var h2;
var _2 = function() {
};
var S = ((g2 = { o: 0, effect: { s: void 0, c: function() {
}, S: function() {
  return _2;
}, d: function() {
} }, subscribe: function() {
  return _2;
}, getSnapshot: function() {
  return 0;
}, S: function() {
}, f: function() {
} })[m] = function() {
}, g2);
var w2 = Promise.prototype.then.bind(Promise.resolve());
function x() {
  if (!h2) h2 = w2(j);
}
function j() {
  var n2;
  h2 = void 0;
  null == (n2 = p2) || n2.f();
}
var P = "undefined" != typeof window ? import_react.useLayoutEffect : import_react.useEffect;
function $(n2) {
  if (void 0 === n2) n2 = 0;
  x();
  var t2 = (0, import_react.useRef)();
  if (null == t2.current) if ("undefined" == typeof window) t2.current = S;
  else t2.current = function(n3) {
    var t3, r3, e3, o3, u3 = 0, f3 = E(function() {
      r3 = this;
    });
    r3.c = function() {
      u3 = u3 + 1 | 0;
      if (o3) o3();
    };
    return (t3 = { o: n3, effect: r3, subscribe: function(n4) {
      o3 = n4;
      return function() {
        u3 = u3 + 1 | 0;
        o3 = void 0;
        f3();
      };
    }, getSnapshot: function() {
      return u3;
    }, S: function() {
      if (null != p2) {
        var n4 = p2.o, t4 = this.o;
        if (0 == n4 && 0 == t4 || 0 == n4 && 1 == t4) {
          p2.f();
          e3 = b2(void 0, this);
        } else if (1 == n4 && 0 == t4 || 2 == n4 && 0 == t4) ;
        else e3 = b2(p2, this);
      } else e3 = b2(void 0, this);
    }, f: function() {
      var n4 = e3;
      e3 = void 0;
      null == n4 || n4();
    } })[m] = function() {
      this.f();
    }, t3;
  }(n2);
  var r2 = t2.current;
  (0, import_shim.useSyncExternalStore)(r2.subscribe, r2.getSnapshot, r2.getSnapshot);
  r2.S();
  if (0 === n2) P(j);
  return r2;
}
Object.defineProperties(u.prototype, { $$typeof: { configurable: true, value: v2 }, type: { configurable: true, value: function(n2) {
  var t2 = n2.data, r2 = $(1);
  try {
    return t2.value;
  } finally {
    r2.f();
  }
} }, props: { configurable: true, get: function() {
  return { data: this };
} }, ref: { configurable: true, value: null } });
function useSignal(n2) {
  return (0, import_react.useMemo)(function() {
    return d(n2);
  }, l2);
}
function useComputed(n2) {
  var t2 = (0, import_react.useRef)(n2);
  t2.current = n2;
  return (0, import_react.useMemo)(function() {
    return w(function() {
      return t2.current();
    });
  }, l2);
}
function useSignalEffect(n2) {
  var t2 = (0, import_react.useRef)(n2);
  t2.current = n2;
  (0, import_react.useEffect)(function() {
    return E(function() {
      return t2.current();
    });
  }, l2);
}

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
};

// node_modules/@vaadin/hilla-react-signals/events.js
function createSetStateEvent(value, signalId, parentSignalId) {
  return {
    id: signalId ?? nanoid(),
    type: "set",
    value,
    accepted: false,
    ...parentSignalId !== void 0 ? { parentSignalId } : {}
  };
}
function createReplaceStateEvent(expected, value, signalId, parentSignalId) {
  return {
    id: signalId ?? nanoid(),
    type: "replace",
    value,
    expected,
    accepted: false,
    ...parentSignalId !== void 0 ? { parentSignalId } : {}
  };
}
function createIncrementStateEvent(delta) {
  return {
    id: nanoid(),
    type: "increment",
    value: delta,
    accepted: false
  };
}
function createInsertLastStateEvent(value) {
  return {
    id: nanoid(),
    type: "insert",
    value,
    position: "last",
    accepted: false
  };
}
function createRemoveStateEvent(entryId) {
  return {
    id: nanoid(),
    type: "remove",
    entryId,
    value: void 0,
    accepted: false
  };
}
function isStateEvent(event) {
  return typeof event === "object" && event !== null && typeof event.id === "string" && typeof event.type === "string" && typeof event.value !== "undefined" && typeof event.accepted === "boolean";
}
function isSnapshotStateEvent(event) {
  return isStateEvent(event) && event.type === "snapshot";
}
function isSetStateEvent(event) {
  return isStateEvent(event) && event.type === "set";
}
function isReplaceStateEvent(event) {
  return isStateEvent(event) && typeof event.expected !== "undefined" && event.type === "replace";
}
function isIncrementStateEvent(event) {
  return isStateEvent(event) && event.type === "increment";
}
function isListSnapshotStateEvent(event) {
  return typeof event === "object" && event !== null && typeof event.id === "string" && event.type === "snapshot" && event.entries instanceof Array && typeof event.accepted !== "undefined";
}
function isInsertLastStateEvent(event) {
  return isStateEvent(event) && event.type === "insert" && event.position === "last";
}
function isRemoveStateEvent(event) {
  return typeof event === "object" && event !== null && typeof event.id === "string" && event.type === "remove" && typeof event.entryId === "string" && typeof event.value === "undefined";
}

// node_modules/@vaadin/hilla-react-signals/FullStackSignal.js
var ENDPOINT = "SignalsHandler";
var _onFirstSubscribe, _onLastUnsubscribe, _subscribeCount;
var DependencyTrackingSignal = class extends u {
  constructor(value, onFirstSubscribe, onLastUnsubscribe) {
    super(value);
    __privateAdd(this, _onFirstSubscribe);
    __privateAdd(this, _onLastUnsubscribe);
    __privateAdd(this, _subscribeCount, -1);
    __privateSet(this, _onFirstSubscribe, onFirstSubscribe);
    __privateSet(this, _onLastUnsubscribe, onLastUnsubscribe);
  }
  S(node) {
    super.S(node);
    if (__privateGet(this, _subscribeCount) === 0) {
      __privateGet(this, _onFirstSubscribe).call(this);
    }
    __privateSet(this, _subscribeCount, __privateGet(this, _subscribeCount) + 1);
  }
  U(node) {
    super.U(node);
    __privateSet(this, _subscribeCount, __privateGet(this, _subscribeCount) - 1);
    if (__privateGet(this, _subscribeCount) === 0) {
      __privateGet(this, _onLastUnsubscribe).call(this);
    }
  }
};
_onFirstSubscribe = new WeakMap();
_onLastUnsubscribe = new WeakMap();
_subscribeCount = new WeakMap();
var _id, _subscription;
var ServerConnection = class {
  constructor(id, config) {
    __privateAdd(this, _id);
    __publicField(this, "config");
    __privateAdd(this, _subscription);
    this.config = config;
    __privateSet(this, _id, id);
  }
  get subscription() {
    return __privateGet(this, _subscription);
  }
  connect() {
    const { client, endpoint, method, params, parentClientSignalId } = this.config;
    __privateGet(this, _subscription) ?? __privateSet(this, _subscription, client.subscribe(ENDPOINT, "subscribe", {
      providerEndpoint: endpoint,
      providerMethod: method,
      clientSignalId: __privateGet(this, _id),
      params,
      parentClientSignalId
    }));
    return __privateGet(this, _subscription);
  }
  async update(event) {
    const onTheFly = !__privateGet(this, _subscription);
    if (onTheFly) {
      this.connect();
    }
    await this.config.client.call(ENDPOINT, "update", {
      clientSignalId: __privateGet(this, _id),
      event
    });
    if (onTheFly) {
      this.disconnect();
    }
  }
  disconnect() {
    var _a;
    (_a = __privateGet(this, _subscription)) == null ? void 0 : _a.cancel();
    __privateSet(this, _subscription, void 0);
  }
};
_id = new WeakMap();
_subscription = new WeakMap();
var $update = Symbol("update");
var $processServerResponse = Symbol("processServerResponse");
var $setValueQuietly = Symbol("setValueQuietly");
var $resolveOperation = Symbol("resolveOperation");
var $createOperation = Symbol("createOperation");
var _pending, _error, _paused, _operationPromises, _FullStackSignal_instances, connect_fn, disconnect_fn;
var FullStackSignal = class extends DependencyTrackingSignal {
  constructor(value, config, id) {
    super(value, () => __privateMethod(this, _FullStackSignal_instances, connect_fn).call(this), () => __privateMethod(this, _FullStackSignal_instances, disconnect_fn).call(this));
    __privateAdd(this, _FullStackSignal_instances);
    __publicField(this, "id");
    __publicField(this, "server");
    __publicField(this, "pending", w(() => __privateGet(this, _pending).value));
    __publicField(this, "error", w(() => __privateGet(this, _error).value));
    __privateAdd(this, _pending, d(false));
    __privateAdd(this, _error, d(void 0));
    __privateAdd(this, _paused, true);
    __privateAdd(this, _operationPromises, /* @__PURE__ */ new Map());
    this.id = id ?? nanoid();
    this.server = new ServerConnection(this.id, config);
    this.subscribe((v3) => {
      if (!__privateGet(this, _paused)) {
        __privateGet(this, _pending).value = true;
        __privateGet(this, _error).value = void 0;
        const signalId = config.parentClientSignalId !== void 0 ? this.id : void 0;
        this[$update](createSetStateEvent(v3, signalId, config.parentClientSignalId));
      }
    });
    __privateSet(this, _paused, false);
  }
  [$createOperation]({ id, promise }) {
    const thens = __privateGet(this, _operationPromises);
    const promises = [];
    if (promise) {
      promises.push(promise);
    }
    if (id) {
      promises.push(new Promise((resolve, reject) => {
        thens.set(id, { resolve, reject });
      }));
    }
    if (promises.length === 0) {
      promises.push(Promise.resolve());
    }
    return {
      result: Promise.allSettled(promises).then((results) => {
        const lastResult = results[results.length - 1];
        if (lastResult.status === "fulfilled") {
          return void 0;
        }
        throw lastResult.reason;
      })
    };
  }
  [$setValueQuietly](value) {
    __privateSet(this, _paused, true);
    super.value = value;
    __privateSet(this, _paused, false);
  }
  async [$update](event) {
    return this.server.update(event).catch((error) => {
      __privateGet(this, _error).value = error instanceof Error ? error : new Error(String(error));
    }).finally(() => {
      __privateGet(this, _pending).value = false;
    });
  }
  [$resolveOperation](eventId, reason) {
    const operationPromise = __privateGet(this, _operationPromises).get(eventId);
    if (operationPromise) {
      __privateGet(this, _operationPromises).delete(eventId);
      if (reason) {
        operationPromise.reject(reason);
      } else {
        operationPromise.resolve();
      }
    }
  }
};
_pending = new WeakMap();
_error = new WeakMap();
_paused = new WeakMap();
_operationPromises = new WeakMap();
_FullStackSignal_instances = new WeakSet();
connect_fn = function() {
  this.server.connect().onSubscriptionLost(() => "resubscribe").onNext((event) => {
    __privateSet(this, _paused, true);
    this[$processServerResponse](event);
    __privateSet(this, _paused, false);
  });
};
disconnect_fn = function() {
  if (this.server.subscription === void 0) {
    return;
  }
  this.server.disconnect();
};

// node_modules/@vaadin/hilla-react-signals/ValueSignal.js
var _pendingRequests, _ValueSignal_instances, applyAcceptedEvent_fn;
var ValueSignal = class extends FullStackSignal {
  constructor() {
    super(...arguments);
    __privateAdd(this, _ValueSignal_instances);
    __privateAdd(this, _pendingRequests, /* @__PURE__ */ new Map());
  }
  set(value) {
    const { parentClientSignalId } = this.server.config;
    const signalId = parentClientSignalId !== void 0 ? this.id : void 0;
    const event = createSetStateEvent(value, signalId, parentClientSignalId);
    const promise = this[$update](event);
    this[$setValueQuietly](value);
    return this[$createOperation]({ id: event.id, promise });
  }
  replace(expected, newValue) {
    const { parentClientSignalId } = this.server.config;
    const signalId = parentClientSignalId !== void 0 ? this.id : void 0;
    const event = createReplaceStateEvent(expected, newValue, signalId, parentClientSignalId);
    const promise = this[$update](event);
    return this[$createOperation]({ id: event.id, promise });
  }
  update(callback) {
    const newValue = callback(this.value);
    const event = createReplaceStateEvent(this.value, newValue);
    const promise = this[$update](event);
    const pendingRequest = { id: nanoid(), callback, canceled: false };
    __privateGet(this, _pendingRequests).set(event.id, pendingRequest);
    return {
      ...this[$createOperation]({ id: pendingRequest.id, promise }),
      cancel: () => {
        pendingRequest.canceled = true;
      }
    };
  }
  [$processServerResponse](event) {
    const record = __privateGet(this, _pendingRequests).get(event.id);
    if (record) {
      __privateGet(this, _pendingRequests).delete(event.id);
      if (!(event.accepted || record.canceled)) {
        this.update(record.callback);
      }
    }
    let reason;
    if (event.accepted || isSnapshotStateEvent(event)) {
      __privateMethod(this, _ValueSignal_instances, applyAcceptedEvent_fn).call(this, event);
    } else {
      reason = `Server rejected the operation with id '${event.id}'. See the server log for more details.`;
    }
    [record == null ? void 0 : record.id, event.id].filter(Boolean).forEach((id) => this[$resolveOperation](id, reason));
  }
};
_pendingRequests = new WeakMap();
_ValueSignal_instances = new WeakSet();
applyAcceptedEvent_fn = function(event) {
  if (isSetStateEvent(event) || isSnapshotStateEvent(event)) {
    this.value = event.value;
  } else if (isReplaceStateEvent(event)) {
    if (JSON.stringify(this.value) === JSON.stringify(event.expected)) {
      this.value = event.value;
    }
  }
};

// node_modules/@vaadin/hilla-react-signals/NumberSignal.js
var _sentIncrementEvents;
var NumberSignal = class extends ValueSignal {
  constructor() {
    super(...arguments);
    __privateAdd(this, _sentIncrementEvents, /* @__PURE__ */ new Map());
  }
  incrementBy(delta) {
    if (delta === 0) {
      return { result: Promise.resolve() };
    }
    this[$setValueQuietly](this.value + delta);
    const event = createIncrementStateEvent(delta);
    __privateGet(this, _sentIncrementEvents).set(event.id, event);
    const promise = this[$update](event);
    return this[$createOperation]({ id: event.id, promise });
  }
  [$processServerResponse](event) {
    if (event.accepted && isIncrementStateEvent(event)) {
      const sentEvent = __privateGet(this, _sentIncrementEvents).get(event.id);
      if (sentEvent) {
        __privateGet(this, _sentIncrementEvents).delete(event.id);
      } else {
        this[$setValueQuietly](this.value + event.value);
      }
      this[$resolveOperation](event.id);
    } else {
      super[$processServerResponse](event);
    }
  }
};
_sentIncrementEvents = new WeakMap();

// node_modules/@vaadin/hilla-react-signals/CollectionSignal.js
var CollectionSignal = class extends FullStackSignal {
  get value() {
    return super.value;
  }
  set value(_3) {
    throw new Error("Value of the collection signals cannot be set.");
  }
};

// node_modules/@vaadin/hilla-react-signals/ListSignal.js
var _head, _tail, _values, _ListSignal_instances, computeItems_fn, handleInsertLastUpdate_fn, handleRemoveUpdate_fn, handleSnapshotEvent_fn;
var ListSignal = class extends CollectionSignal {
  constructor(config) {
    const initialValue = [];
    super(initialValue, config);
    __privateAdd(this, _ListSignal_instances);
    __privateAdd(this, _head);
    __privateAdd(this, _tail);
    __privateAdd(this, _values, /* @__PURE__ */ new Map());
  }
  [$processServerResponse](event) {
    if (!event.accepted) {
      this[$resolveOperation](event.id, `Server rejected the operation with id '${event.id}'. See the server log for more details.`);
      return;
    }
    if (isListSnapshotStateEvent(event)) {
      __privateMethod(this, _ListSignal_instances, handleSnapshotEvent_fn).call(this, event);
    } else if (isInsertLastStateEvent(event)) {
      __privateMethod(this, _ListSignal_instances, handleInsertLastUpdate_fn).call(this, event);
    } else if (isRemoveStateEvent(event)) {
      __privateMethod(this, _ListSignal_instances, handleRemoveUpdate_fn).call(this, event);
    }
    this[$resolveOperation](event.id);
  }
  insertLast(value) {
    const event = createInsertLastStateEvent(value);
    const promise = this[$update](event);
    return this[$createOperation]({ id: event.id, promise });
  }
  remove(item) {
    const entryToRemove = __privateGet(this, _values).get(item.id);
    if (entryToRemove === void 0) {
      return { result: Promise.resolve() };
    }
    const removeEvent = createRemoveStateEvent(entryToRemove.value.id);
    const promise = this[$update](removeEvent);
    return this[$createOperation]({ id: removeEvent.id, promise });
  }
};
_head = new WeakMap();
_tail = new WeakMap();
_values = new WeakMap();
_ListSignal_instances = new WeakSet();
computeItems_fn = function() {
  let current = __privateGet(this, _head);
  const result = [];
  while (current !== void 0) {
    const entry = __privateGet(this, _values).get(current);
    result.push(entry.value);
    current = entry.next;
  }
  return result;
};
handleInsertLastUpdate_fn = function(event) {
  if (event.entryId === void 0) {
    throw new Error("Unexpected state: Entry id should be defined when insert last event is accepted");
  }
  const valueSignal = new ValueSignal(event.value, { ...this.server.config, parentClientSignalId: this.id }, event.entryId);
  const newEntry = { id: valueSignal.id, value: valueSignal };
  if (__privateGet(this, _head) === void 0) {
    __privateSet(this, _head, newEntry.id);
    __privateSet(this, _tail, __privateGet(this, _head));
  } else {
    const tailEntry = __privateGet(this, _values).get(__privateGet(this, _tail));
    tailEntry.next = newEntry.id;
    newEntry.prev = __privateGet(this, _tail);
    __privateSet(this, _tail, newEntry.id);
  }
  __privateGet(this, _values).set(valueSignal.id, newEntry);
  this[$setValueQuietly](__privateMethod(this, _ListSignal_instances, computeItems_fn).call(this));
};
handleRemoveUpdate_fn = function(event) {
  const entryToRemove = __privateGet(this, _values).get(event.entryId);
  if (entryToRemove === void 0) {
    return;
  }
  __privateGet(this, _values).delete(event.id);
  if (__privateGet(this, _head) === entryToRemove.id) {
    if (entryToRemove.next === void 0) {
      __privateSet(this, _head, void 0);
      __privateSet(this, _tail, void 0);
    } else {
      const newHead = __privateGet(this, _values).get(entryToRemove.next);
      __privateSet(this, _head, newHead.id);
      newHead.prev = void 0;
    }
  } else {
    const prevEntry = __privateGet(this, _values).get(entryToRemove.prev);
    const nextEntry = entryToRemove.next !== void 0 ? __privateGet(this, _values).get(entryToRemove.next) : void 0;
    if (nextEntry === void 0) {
      __privateSet(this, _tail, prevEntry.id);
      prevEntry.next = void 0;
    } else {
      prevEntry.next = nextEntry.id;
      nextEntry.prev = prevEntry.id;
    }
  }
  this[$setValueQuietly](__privateMethod(this, _ListSignal_instances, computeItems_fn).call(this));
};
handleSnapshotEvent_fn = function(event) {
  event.entries.forEach((entry) => {
    __privateGet(this, _values).set(entry.id, {
      id: entry.id,
      prev: entry.prev,
      next: entry.next,
      value: new ValueSignal(entry.value, { ...this.server.config, parentClientSignalId: this.id }, entry.id)
    });
    if (entry.prev === void 0) {
      __privateSet(this, _head, entry.id);
    }
    if (entry.next === void 0) {
      __privateSet(this, _tail, entry.id);
    }
  });
  this[$setValueQuietly](__privateMethod(this, _ListSignal_instances, computeItems_fn).call(this));
};

export {
  r,
  n,
  u,
  d,
  w,
  E,
  useSignal,
  useComputed,
  useSignalEffect,
  FullStackSignal,
  ValueSignal,
  NumberSignal,
  ListSignal
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-U5N45VGV.js.map
